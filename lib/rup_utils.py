#! /usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (C) 2004-21 Dr. Ralf Schlatterbeck Open Source Consulting.
# Reichergasse 131, A-3411 Weidling.
# Web: http://www.runtux.com Email: office@runtux.com
# All rights reserved
# ****************************************************************************
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
# ****************************************************************************

from __future__ import print_function
import os
import shutil
from   tempfile import mkstemp

def abo_max_invoice (db, abo) :
    if not len (abo ['invoices']) :
        return None
    maxinv  = db.invoice.getnode (abo ['invoices'][0])
    maxdate = maxinv ['period_end']
    for i in abo ['invoices'] :
        inv = db.invoice.getnode (i)
        d   = inv ['period_end']
        if maxdate < d :
            maxdate = d
            maxinv  = inv
    return maxinv
# end def abo_max_invoice

def uni (x) :
    return b2s (x.decode ("latin1").encode ("utf-8"))
# end def uni

translation_table = {}
translation_table.update (dict ([(k, ord ('A')) for k in range (192, 198)]))
translation_table [198] = b'AE'.decode ('latin-1')
translation_table [199] = ord ('C')
translation_table.update (dict ([(k, ord ('E')) for k in range (200, 204)]))
translation_table.update (dict ([(k, ord ('I')) for k in range (204, 208)]))
translation_table [208] = ord ('D')
translation_table [209] = ord ('N')
translation_table.update (dict ([(k, ord ('O')) for k in range (210, 215)]))
translation_table.update (dict ([(k, ord ('U')) for k in range (217, 221)]))
translation_table [221] = ord ('Y')
translation_table [223] = b'ss'.decode ('latin-1')
translation_table.update (dict ([(k, ord ('a')) for k in range (224, 230)]))
translation_table [230] = b'ae'.decode ('latin-1')
translation_table [231] = ord ('c')
translation_table.update (dict ([(k, ord ('e')) for k in range (232, 236)]))
translation_table.update (dict ([(k, ord ('i')) for k in range (236, 240)]))
translation_table [240] = ord ('d')
translation_table [241] = ord ('n')
translation_table.update (dict ([(k, ord ('o')) for k in range (242, 247)]))
translation_table.update (dict ([(k, ord ('u')) for k in range (249, 253)]))
translation_table [253] = ord ('y')
translation_table [255] = ord ('y')

def translate (x) :
    """ Translate utf-8 string to lookalike utf-8 string without accents

        >>> translate ('äöüÄÖÜß')
        'aouaouss'
    """
    t = x.translate (translation_table)
    return t.lower ()
# end def translate

USER_SINGLE = """
<tal:block metal:define-macro="%(macro_name)s">
 <tal:block tal:condition="python:not context [name].is_edit_ok ()"
  tal:replace="python: context [name]"/>
 <select tal:attributes="name name"
  tal:condition="python: context [name].is_edit_ok ()">
  <option value=""
          tal:content="dont_care"></option>
  <!-- autogenerated -->
%(option_list)s
  <!-- autogenerated -->
</select>
<script language="javascript"
        tal:content="structure string:
<!--
select_box = document.${form}.${name};
if (select_box)
  {
    for (i = 0; i < select_box.length; i++)
      {
        if (select_box.options [i].value == ${selected})
          select_box.options [i].selected = true;
        else
          select_box.options [i].selected = false;
      }
  }
-->
"></script>
</tal:block>
"""

USER_MULTI = """
<tal:block metal:define-macro="%(macro_name)s">
 <tal:block tal:condition="python:not %(condition)s"
  tal:replace="python: context [name]"/>
 <select multiple tal:condition="python: %(condition)s"
         tal:attributes="size size;
                         name name">
  <option value=""
          tal:content="dont_care"></option>
  <!-- autogenerated -->
%(option_list)s
  <!-- autogenerated -->
</select>
<script language="javascript"
        tal:content="structure string:
<!--
select_box = document.${form}.${name};
selected   = new Array (${selected});
if (select_box)
  {
    for (i = 0; i < select_box.length; i++)
      {
        for (j = 0; j < selected.length; j++)
          {
            if (select_box.options [i].value == selected [j])
              select_box.options [i].selected = true;
          }
      }
  }
-->
"></script>
</tal:block>
"""

OPTION_FMT = """  <option value="%s">%s</option>"""

def update_userlist_html (db, cl = None) :
    """newly create user_list.html macro page
    """
    if not cl :
        cl = db.user
    root       = os.path.join (db.config.TRACKER_HOME, "html")
    userlist   = "userlist.html"
    f, tmpname = mkstemp (".html", "userlist", root)
    f = os.fdopen (f, 'w')
    # all 'real' users
    spec = {}
    if 'status' in cl.properties :
        stati = db.user_status.filter (None, dict (is_nosy = True))
        spec  = { 'status' : stati }
    users      = cl.filter ( None # full text search
                           , filterspec = spec
                           , sort       = ("+", "username")
                           )
    options  = [OPTION_FMT % (id, cl.get (id, "username")) for id in users]

    f.write (USER_SINGLE % { "macro_name"  : "user"
                           , "option_list" : "\n".join (options)
                           }
            )
    f.write (USER_MULTI  % { "macro_name"  : "user_multi"
                           , "option_list" : "\n".join (options)
                           , "condition"   : "context [name].is_edit_ok ()"
                           }
            )
    f.write (USER_MULTI  % { "macro_name"  : "user_multi_read"
                           , "option_list" : "\n".join (options)
                           , "condition"   : "True"
                           }
            )

    # all users (incl. mail alias users)
    # RSC: now there are no mail alias users -- and we don't want
    # invalid users here, so use the same filterspec.
    spec = {}
    if 'status' in cl.properties :
        stati  = db.user_status.filter (None, dict (is_nosy = True))
        spec   = {"status" : stati}
    users    = cl.filter ( None # full text search
                         , filterspec = spec
                         , sort       = ("+", "username")
                         )
    options  = [OPTION_FMT % (id, cl.get (id, "username")) for id in users]

    f.write (USER_MULTI  % { "macro_name"  : "nosy_multi"
                           , "option_list" : "\n".join (options)
                           , "condition"   : "True"
                           }
            )

    f.close ()
    shutil.move (tmpname, os.path.join (root, userlist))
# end def update_userlist_html
